%style
  :plain
    .code-vsplit {
      display: flex;
      justify-content: space-between;
    }

    .code-vsplit > * {
      width: 46% !important;
      display: flex !important;
    }

    .code-vsplit code {
      width: 100%;
    }

    .left {
      text-align: left;
    }

    .green-text {
      color: #3cdc8b;
    }

%section(class="center"){"data-transition" => "none"}
  %h2 Approaching GraphQL

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h2 What is GraphQL?
  %ol
    %li A <span class="green-text">query language</span> for APIs
    %li A <span class="green-text">runtime</span> for fulfilling those queries with your existing data.

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h2 What is GraphQL not?
  %ol
    %li An ORM
    %li Data storage layer

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Differences with REST?
  %h5 Single endpoint
  %pre
    %code(class="clojure")
      :preserve
        /graphql
  %h5 vs resource URLs
  %pre
    %code(class="clojure")
      :preserve
        /
        /posts
        /posts/1
        ...

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Differences with REST?
  %h5 Single representation
  %pre
    %code(class="clojure")
      :preserve
        content-type: application/json
  %h5 vs multiple representations
  %pre
    %code(class="clojure")
      :preserve
        content-type: text/html
        content-type: application/xhtml+xml
        content-type: application/json
        ...
%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Differences with REST?
  %h5 Fewer status codes
  %pre
    %code(class="clojure")
      :preserve
        200 OK
        400 Bad Request

  %h5 vs many status codes
  %pre
    %code(class="clojure")
      :preserve
        200 OK
        201 Created
        202 Accepted
        204 No Content
        418 I'm a teapot
        ...
%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Differences with REST?
  %h5 Single request method (typically)
  %pre
    %code(class="clojure")
      :preserve
        POST
  %h5 vs varied reqeust methods
  %pre
    %code(class="clojure")
      :preserve
        GET
        POST
        PUT
        PATCH
        DELETE
        ...

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>

  :markdown
    GraphQL defines an API <span class="green-text">schema</span> to organize
    available resources. Resources are declared using static types and
    connected to one another via fields.

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h6 Reads
  .code-vsplit
    %pre
      %code(class="clojure")
        :preserve
          # Query
          query {
            authors {
              name
              posts {
                title
              }
            }
          }
    %pre
      %code(class="haskel")
        :preserve
          # Schema
          type Author {
            name: String
            posts: [Post]
          }

          type Post {
            title: String
          }

  %pre
    %code
      :preserve
        {
          "data": {
            "authors": [{
              "name": "Dat Boi",
              "posts": [
                { "title": "Here he come" }
              ]
            }
          }]
        }

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h6 Writes
  .code-vsplit
    %pre
      %code(class="clojure")
        :preserve
          # Query
          mutation createUser {
            createUser(email: "baz.com") {
              id
              email
            }
          }

    %pre
      %code(class="haskel")
        :preserve
          # Schema
          type Mutation {
            createUser(email: String): User
          }

  %pre
    %code
      :preserve
        {
          "data": {
            "createUser": {
              "id": "3",
              "email": "baz@example.com",
            }
          }
        }


%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  :markdown
    * Scalars
    * Objects
    * Enums
    * Inputs
    * Interfaces
    * Unions
    * Modifiers

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Builtin scalars
  %pre
    %code(class="ruby")
      :preserve
        ID         # A unique identifier
        Int        # A signed 32â€bit integer.
        Float      # A signed double-precision floating-point value.
        String     # A UTFâ€8 character sequence.
        Boolean    # `true` or `false`.

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Custom scalars. Create any type you want
  %pre
    %code(class="haskel")
      :preserve
        scalar Time

        type Post {
          time: Time
        }

  %pre
    %code(class="ruby")
      :preserve
        # Create parse and serialize handlers in your runtime.
        TimeType = GraphQL::ScalarType.define do
          name "Time"
          description "Time since epoch in seconds"

          coerce_input ->(value) { Time.at(Float(value)) }
          coerce_result ->(value) { value.to_f }
        end

        # irb(main):001:0> Time.at(Float(1234567890))
        # => 2009-02-13 17:31:30 -0600

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Enum

  %pre
    %code(class="haskel")
      :preserve
        # Enums are a collection of scalars referencing specific values
        enum ExpenseType {
          FOOD
          TRAVEL
          PARKING
        }

        type Query {
          expenses(type: ExpenseType): [Expense]
        }

  .code-vsplit
    %pre
      %code(class="haskel")
        :preserve
          query {
            expenses(type: PARKING) {
              merchant
              amount
            }
          }
    %pre
      %code(class="haskel")
        :preserve
          {
            "data": {
              "expenses": [
                {"merchant": "Regional airport", "amount": 40.23}
              ]
            }
          }

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Objects
  %pre
    %code(class="haskel")
      :preserve
        enum CompanyType { CNN }

        type Author {
          name: String
          posts: [Post]
        }

        type Post {
          title: String
        }

        type Query {
          bloggers(type: CompanyType): [Author]
        }

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Inputs

  :markdown
    Define an explicit shape of all input objects for mutations. Save the work
    of manually parsing and validating the shape and size of user input. Let
    GraphQL do the grunt work!

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Inputs

  %pre
    %code(class="clojure")
      :preserve
        mutation createExpense($input: CreateExpenseInput!) {
          createExpense(input: $input) {
            id
          }
        }

  %pre
    %code(class="haskel")
      :preserve
        input CreateExpenseInput {
          type: ExpenseType!
          amount: Float!
          description: String
        }

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Modifiers

  :markdown
    When reading data the GraphQL runtime responds with error messages
    communicating the state of the fulfilled query. Any non conformity to the
    schema is reported as an error.

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Modifiers

  %pre
    %code(class="ruby")
      :preserve
        !     # Non null
        []    # List


        # How it works
        name: String         # nullable name
        name: String!        # non nullable name
        names: [String]      # nullable list of nullable names
        names: [String]!     # non nullable list of nullable names
        names: [String!]!    # non nullable list of non nullable names

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Modifiers on types

  .code-vsplit
    %pre
      %code(class="clojure")
        :preserve
          query {
            user {
              name
            }
          }

    %pre
      %code(class="haskel")
        :preserve
          type User {
            id: ID!
            name: String!
          }

          type Query {
            user: User
          }

  %pre
    %code
      :preserve
        {
          "errors": [
            { "message": "Cannot return null for non-nullable field User.name.", }
          ],
          "data": {
            "user": null
          }
        }

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Modifiers on arguments

  .code-vsplit
    %pre
      %code(class="clojure")
        :preserve
          query {
            user {
              name
            }
          }

    %pre
      %code(class="haskel")
        :preserve
          type User {
            id: ID!
            name: String!
          }

          type Query {
            user(id: ID!): User
          }

  %pre
    %code
      :preserve
        {
          "errors": [
            {
              "message": "Field \"viewer\" argument \"id\" of type \"ID!\" is required but not provided.",
            }
          ]
        }

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Modifiers on inputs ðŸ˜

  .code-vsplit
    %pre
      %code(class="clojure")
        :preserve
          mutation {
            createUser(input: { name: "Jazzy Scooter" }) {
              name
            }
          }

    %pre
      %code(class="haskel")
        :preserve
          input CreateUserInput {
            name: String!
            email: String!
          }

          type Mutation {
            createUser(input: CreateUserInput!): User
          }

  %pre
    %code
      :preserve
        {
          "errors": [
            {
              "message": "Field CreateUserInput.email of required type String! was not provided.",
            }
          ]
        }


%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Unions

  :markdown
    A set of possible types with no guarantee of consistency between fields.

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Unions

  %pre
    %code(class="haskel")
      :preserve
        type SocialMediaPost {
          content: String
        }

        type BlogPost {
          title: String
          content: String
        }

        union PostUnion = BlogPost | SocialMediaPost

        type Query {
          posts: [PostUnion]
        }

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Unions
  .code-vsplit
    %pre
      %code(class="clojure")
        :preserve
          query {
            posts {
              ... on SocialMediaPost {
                content
              }
              ... on BlogPost {
                title
                content
              }
            }
          }

    %pre
      %code(class="haskel")
        :preserve
          {
            "data": {
              "posts": {
                { "content": "I ate a donut!" },
                { "title": "ðŸ© are tasty.", "content": "That is all." },
              }
            }
          }

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Interface

  :markdown
    An abstract type declaring common fields and arguments. Any object
    implementing an interface is guarantees certain fields exist.

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Interface

  %pre
    %code(class="haskel")
      :preserve
        interface MutationResult {
          notice: String
          success: Boolean!
        }

        type CreateExpensePayload implements MutationResult {
          result: Expense
          success: Boolean!
        }

        mutation {
          createExpense(input: CreateExpenseInput!): CreateExpensePayload
        }

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">query language</span>
  %h5 Expressive type system
  %p Interface

  .code-vsplit
    %pre
      %code(class="clojure")
        :preserve
          mutation createExpense($input: CreateExpenseInput!) {
            createExpense(input: $input) {
              success
              result {
                amount
              }
            }
          }

    %pre
      %code(class="haskel")
        :preserve
          {
            "data": {
              "createExpense": {
                "success": true,
                "result": {
                  "amount": 42.0
                }
              }
            }
          }

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">runtime</span>
  :markdown
    GraphQL is a <span class="green-text">runtime</span> layer between the
    client and your business logic. It is responsible for <span class="green-text">analyzing</span>,
    <span class="green-text">validating</span>, and <span class="green-text">resolving</span> incoming requests.

    GraphQL implementations currently exist for:

    C# / .NET, Clojure, Elixir, Erlang, Go, Groovy, Java, JavaScript, PHP, Python, Scala, Ruby

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">runtime</span>
  %h5 Analysis
  :markdown
    Queries can become complex and tax your system of resources ðŸ˜«. The runtime
    performs complexity and depth analysis on all incoming requests, and if you
    wish, it can only allow queries within a specific threshold.
  %pre
    %code(class="ruby")
      :preserve
        MySchema = GraphQL::Schema.define do
         max_depth 10          # Prevent deeply nested resources
         max_complexity 100    # Reject complex queries
        end

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">runtime</span>
  %h5 Validation
  %pre
    %code(class="haskel")
      :preserve
        query {
          user {
            juicyBitcoins
          }
        }
  %pre
    %code
      :preserve
        {
          "errors": [
            {
              "message": "Cannot query field \"juicyBitcoins\" on type \"User\".",
              "locations": [
                {
                  "line": 3,
                  "column": 5
                }
              ]
            }
          ]
        }

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">runtime</span>
  %h5 Resolution
  :markdown
    The runtime resolves fields. By default, fields are resolved from the
    underlying struct and the values are returned for the field.

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">runtime</span>
  %h5 Resolution
  :markdown
    Resolvers are anonymous functions called with three arguments

  %pre
    %code
      :preserve
        query {
          currentUser {
            email
          }
        }

  %pre
    %code(class="javascript")
      :preserve
        const resolvers = {
          Query: {
            currentUser: (object, args, context) => context.currentUser
          }
        }
        // object      # In memory object (think ORM)
        // args        # GQL query arguments
        // context     # Global state

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 GraphQL is a <span class="green-text">runtime</span>
  %h5 Resolution
  :markdown
    Define resolvers inline, if you want.

  %pre
    %code(class="javascript")
      :preserve
        const resolvers = {
          User: {
            emailAddressLength: object => object.email.length,
            randomFloat: () => Math.random()
          }
        }

  .code-vsplit
    %pre
      %code(class="javascript")
        :preserve
          type User {
            email: String
            emailAddressLength: Int
            randomFloat: Float
          }
    %pre
      %code(class="javascript")
        :preserve
          {
            "data": {
              "currentUser": {
                "email": "foo@example.com",
                "emailAddressLength": 15,
                "randomFloat": 0.008373373072433798,
              }
            }
          }

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Benefits
  %h5 There are many. Here are a few.

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Benefits
  %h5 Explorable APIs
  :markdown
    Add descriptions. Deprecate fields. Communicate.
  = image_tag "talks/approaching-graphql/graphiql-search.gif"

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Benefits
  %h5 Explorable APIs
  :markdown
    Add descriptions. Deprecate fields. Communicate.
  = image_tag "talks/approaching-graphql/intellisense.png"

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Benefits
  %h5 Explorable APIs
  :markdown
    Add descriptions. Deprecate fields. Communicate.
  = image_tag "talks/approaching-graphql/deprecated.png"

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Benefits
  %h5 Explorable APIs
  :markdown
    Add descriptions. Deprecate fields. Communicate.
  = image_tag "talks/approaching-graphql/enum-descriptions.png"

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Benefits
  %h5 Explorable APIs
  :markdown
    Add descriptions. Deprecate fields. Communicate.

    Some good examples:

    * [Github API](https://developer.github.com/v4/explorer/)
    * [StarWars API](http://graphql.org/swapi-graphql/)

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Benefits
  %h5 Static Types ðŸ‹ï¸
  :markdown
    Push input paramater validations out into the GraphQL runtime and build
    user interfaces to consume and bubble up responses.

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Benefits
  %h5 Declarative User Interface
  :markdown
    Design components that speak GraphQL and only request data required to render the component

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Benefits
  %h5 Declarative User Interface

  %p React example

  %pre
    %code(class="javascript")
      :preserve
        const query = gql`
          query {
            greeting
          }
        `

        const Greeter = props => (
          <div>
            <h1> {props.data.greeting} </h1>
          </div>
        )

        export default graphql(query)(Greeter);

  :markdown
    <small>See [Apollo GraphQL](https://github.com/apollographql) for more information</small>

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Benefits
  %h5 Composable APIs
  :markdown
    Present *N* distinct GraphQL APIs into a single schema with a concept known as _schema stitching_.

  :markdown
    <small>See [Schema stitching](https://www.apollographql.com/docs/graphql-tools/schema-stitching.html) for more information.</small>
    <small>[Example](https://launchpad.graphql.com/130rr3r49)</small>
%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Benefits
  %h5 Composable APIs
  = image_tag "talks/approaching-graphql/stitching.jpg"

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Benefits
  %h5 Performance Insight
  :markdown
    The GraphQL runtime provides executions hooks into each of your resolvers.
    It is possible to know the time it takes to resolve each field.

%section{"data-transition" => "none", "data-background" => "rebeccapurple"}
  %h3 Benefits
  %h5 Performance Insight
  = image_tag "talks/approaching-graphql/tracing.jpg"

%section(class="center"){"data-transition" => "none"}
  %h3 Questions?
  %h5 The end ðŸ‘‹

